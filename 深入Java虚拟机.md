## Java内存区域与内存溢出

###运行时数据区域

Java虚拟机在执行Java程序过程中会把它所管理的内存区域划分若干个不同的数据区域

####程序计数器（Programm Counter Register）

程序计数器是一块较小的内存空间。它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时，就是通过这个计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理等基础功能都是需要依赖这个计数器来完成的。

在任一时刻，一个处理器都只会执行一条线程中的指令，因此，为了线程切换后能后恢复到正确的执行位置，每一条线程都需要一个独立的程序计数器，计数器之间不会互相影响，独立存储，我们称为“线程私有的”。

#### Java虚拟机栈（Java Virtual Machine Stacks）

**Java虚拟机栈也是线程私有的**，它的生命周期与线程相同。**虚拟机栈描述的是java方法执行的内存模型**，每个方法在执行时会创建一个栈帧（stack frame）用于存储局部变量表，操作数栈，动态链接，方法出口等信息。

**局部变量表**，存放了**编译期**可知的各种基本数据类型，对象引用和returnAddress类型。

#### 本地方法栈（Native Method Stack）

虚拟机栈是为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。

#### Java堆 （Java Heap）

Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。

#### 方法区（Method Area）

方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码片段等数据

#### 运行时常量池（Runtime Constant Pool）

运行时常量池是方法区的一部分。Class文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项重要的常量池（Constant Pool Table）,用于存放编译期生成的各种字面变量和符号引用，这部分内容**将在类加载后进入方法区的运行时常量池存放**。

**Java并不一定要求常量一定只有在编译期间产生，也可以在运行期间将新的常量放入池中。**

#### 直接内存

手动分配的。

NIO（new Input/Output）类，引入了一种基于通道与缓冲区的I/O方式，它可以使用native函数库直接分配堆外内存，然后通过一种存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。

### HotSpot虚拟机对象探秘

#### 对象的创建

1 虚拟机遇到new命令，首先检查这个指令的参数是否能在**常量池**中定位到一个类的符号引用，并且检查这个符号引用所代表的类是否已被加载，解析和初始化过。如果没有，就必须要先执行相应的类加载。

2 在类检查通过了，虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便知道了，为对象分配空间任务等同于把一块确定大小的内存从**Java堆**中划分出来

3 虚拟机要对对象进行必要的设置，例如这个对象时哪个类的实例，对象哈希码等。这些信息存放在对象的对象头（Object Header）

4 执行完new指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

#### 对象的内存布局

对象在内存中布局，分为3块，对象头（Header），实例对象（Instance），对其填充（Padding）

**对象头**

分为两个部分，第一部分用于**存储对象自身的运行时数据**，如哈希码，GC分代年龄，锁状态，线程持有锁，偏向线程ID等。官方称为Mark Word。

另一个部分是**类型指针**，对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

如果对象是一个Java数组，那在对象头中还必须要有一块用于记录数据长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是数组的元数据中却无法确定数组的大小。

**实例数据部分**

是对象真正存储的部分，也是在程序代码中所定义的各种类型的字段内容。（我的理解，Java并不能给实例动态的添加字段，属性）。

**对齐填充**

HotSpot要求对象的大小的必须是8个字节的整数倍，所以有时需要填充。



## 垃圾收集器与内存分配策略

程序计数器，虚拟机栈，本地方法栈这个3个区域随线程而生，随线程而亡。栈中的栈帧随着方法的进入和退出而有序地执行出栈和入栈的操作。这一部分的内存分配和回收都是确定的。

###GC Roots

通过一些称为GC Roots的对象作为起始点，从这些节点开始搜索，搜索和该节点法生直接或者间接引用关系的对象，将这些对象以链的形式组合起来，形成一张关系网，又叫做引用链。最后垃圾收集器就回收一些不在这张关系网上的对象。

有四种对象可以作为GC Roots

1 栈帧中的引用对象

2 静态属性引用对象

3 常量引用的对象

4 本地方法栈中JNI引用的对象

#### 引用

**强引用**

指在程序代码普遍存在的，类似”Object o = new Object()“。只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象

**软引用**

描述一些还有用但非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。

**弱引用**

被弱引用关联的对象只能生存到下一次垃圾回收发生之前，当垃圾收集器开始工作时，无论当时内存是否足够，都会回收只被弱引用关联的对象。

**虚引用**

一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。它的唯一目的是，能在这个对象被收集器回收时收到一个系统通知。PhantomReference类来实现虚引用。

#### 二次标记

第一次标记不在引用链中的对象。如果该对象有有finalize方法，会将对象放入到F-Queue队列中，之后由一个由虚拟机自动建立的，低优先级的Finalizer线程去执行它。随后GC将对F-Queue中的对象进行第二次小规模的标记。如果对象在finalize函数中自救成功，那么第二次标记时，它将被移除即将回收的集合，否则它就真正被回收。

**finalize函数**

被gc时会调用，程序退出时会调用。因为任何一个对象的finalize()的方法都只会被系统自动的调用一次，如果对象面临下一次的回收，它的finalize()不会被执行。**尽量避免去使用它**。

#### 回收方法区

**废弃常量**

系统中没有一个String对象叫“ABC”，则就回收。常量池中的其他类（接口），方法，字段的符号引用类似。

**无用的类**

1 该类所有实例都已经被回收

2 加载该类的ClassLoader已经被回收

3 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

###垃圾回收算法

#### 标记-清除算法

首先标记所有需要回收的对象，在标记完成之后统一回收所有被标记的对象。会造成大量不连续的内存碎片。

#### 复制算法

它将可用的内存按照容量分为大小相等的两块，每次只用其中的一块。带一块内存用完了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

**回收新生代**

将内存分配为一块较大的Eden空间和两块较小的Survivior空间，每次使用Eden和其中一块Survivior。当回收时，将Eden和刚才使用的Survivior空间还存活的对象一次性复制到另外一块Survivor空间上（如果另一块Survivor没有足够的空间存放上一次新生代收集下来的存活对象时，这些对象直接通过分配担保机制进入老年代）最后清理Eden和刚才使用的survivor空间。HotSpot虚拟机默认Eden和Survivor的比例时8:1。

####标记-整理算法

首先标记所有需要回收的对象，在标记完成之后，让所有存活的对象都向一段移动，然后直接清理掉端边界以外的内存。

#### 分代收集算法

根据对象存活周期的不同将内存划分为几块。

一般新生代使用复制算法回收，老年代使用标记-整理算法回收。

### 垃圾收集器

#### Serial收集器（新生代）

它只会利用一个CPU或者一条线程去完成垃圾收集工作。在它进行垃圾回收时，必须要停止其他所有的线程，知道它收集结束

#### ParNew收集器（新生代）

Serial收集器的多线程版本。

#### Parallel Seavenge收集器（新生代）

目的是达到一个可控的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 / （用户代码时间 + 垃圾收集时间）。

#### Serial Old收集器（老年代）

Serial收集器的老年代版本。使用标记-整理算法

#### Parallel Old收集器（老年代）

是Parallel Seavenge收集器的老年代版本，使用多线程和标记-整理算法。

#### CMS收集器（Concurrent Mark Sweep）（老年代）

是一种以获取最短回收停顿时间为目标的收集器。**第一次实现了让垃圾回收线程和用户线程基本上同时工作。**使用了标记-清除算法。

1. 初始化标记（CMS initial mark）**stop the world**

   只标记与GC Roots能**直接关联的对象**。

2. 并发标记（CMS concurrent mark）

   对于GC Roots进行可达性分析。并发标记

3.  重新标记（CMS remark）**stop the world**

   修正在并发标记期间内因用户线程运作而导致标记产生变动的那一部分对象

4. 并发清除（CMS concurrent sweep）

   并发清除

**缺点**

1. 吃CPU资源

2. 浮动垃圾

   **由于CMS并发清理阶段，用户线程还在运行着，也会导致新的垃圾产生。**所以CMS只好留待下一次GC时再清除掉。

3. 内存碎片 

#### G1收集器（新生代和老年代）

它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是无力隔离，它们是一部分（Region）的集合。

1. 初始标记（Initial Marking）**stop the world**

   只标记与GC Roots能**直接关联的对象**。并且修改TAMS（Next to at Mark Start）的值，让下一阶段用户并发运行时，能正确可用的Region中创建对象。

2. 并发标记（Concurrent Marking）

   对于GC Roots进行可达性分析。

3.  最终标记（Final Marking）**stop the world**

   修正在并发标记期间内因用户线程运作而导致标记产生变动的那一部分对象。虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面。最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中。

4. 筛选回收（Living Data Counting and Evacuation）

   对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。

#### GC日志

> 33.125 [GC [DefNew 3324K->152K(3712K), 0.0026 secs] 3324K->152K(10240K) 0.00316secs

最前面数字 33.125 表示GC发生的时间,从Java虚拟机启动以来经历的秒数

[GC  [ Full GC 表示这次垃圾回收的类型，Full表示，发生了Stop-The-World

[DefNew 表示GC发生的区域，与GC收集器有关。

3324K->152K(3712K), GC前该内存区域已使用容量->GC后该内存区域已使用的容量（该内存区域总容量）

0.0026 secs该内存区域GC所占用的时间

3324K->152K(10240K) GC前Java堆已使用容量->GC后Java堆已使用的容量（Java堆总容量）

0.00316secs 总的时间，包含I/O等

### 内存分配和回收策略

对象的内存分配，就是在堆上分配，对象主要分配在新生代Eden区上，如果启动了本地线程分配缓冲，将线程优先分配TLAB上分配。

> TLAB（Thread Local Allocation Buffer） 在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一块空间，如果需要分配内存，就在自己的空间上分配。

**对象优先分配在Eden上**

**大对象直接进入老年代**

**长期存活的对象将进入老年代**  	

年龄计数器，在新生代没熬过一次gc，则加1。满足设置值，则移动到老年代。

**动态对象年龄判断**		

如果在Survivor空间中相同年龄所有对象大小综合大雨Survivor空间的一般，年龄大于等于该年龄的对象就直接进入老年代

**空间分担担保**

虚拟机会先检查老年代最大可用的连续空间是否大于**新生代所有对象的空间或者历次晋升到老年代对象的平均大小**，如果这个条件成立，那么进行新生代GC是安全的，否则进行一次Full GC。



## 虚拟机性能监控和故障处理工具

###命令行工具

|  名称  | 主要作用                                                     |
| :----: | ------------------------------------------------------------ |
|  jps   | JVM Process Status Tool，显示指定系统内所有HotSpot虚拟机进程 |
| jstat  | JVM Statistics Monitoring Tool，用于收集HotSpot虚拟机个方面运行数据 |
| jinfo  | Configuration Info for Java，显示虚拟机配置信息              |
|  jmap  | Memory Map for Java，生成虚拟机的内存转储快照（heapdump文件） |
|  jhat  | JVM Heap Dump Browser，用于分析heapdump文件，它会建立一个HTTP/HTML服务器让用户可以在浏览器上查看分析结果 |
| jstack | Stack Trace for Java，显示虚拟机的线程快照                   |

### 可视化工具

- JConsole
- VisualVM

##调优案例分析与实战

通过64位JDK来使用内存

- 内存回收导致长时间的停顿
- 相同程序在64位JDK消耗的内存一般比32位的大，由于指针膨胀，数据类型对齐等原因

使用若干个32位虚拟机建立逻辑集群来利用硬件资源

- 节点的全局竞争，磁盘竞争
- 很难高效的利用某些资源池
- 受到32位的内存限制
- 大量的使用本地缓存

垃圾回收时，虚拟机虽然会对Direct Memory进行回收，但是Direct Memory却不能向新生代，老年代那样，发现空间不足就通知收集器进行垃圾回收，**它只能等待老年代满了后发生Full GC，然后帮它清理掉内存的废弃对象**，否者它只能抛出内存溢出异常。

## 类文件结构

###Class文件结构

各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——字节码（ByteCode）

**实现语言无关性的基础是虚拟机和字节码存储格式，Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件有所关联，Class文件中包括了Java虚拟机指令集和符号表以及若干其他辅助信息。**

Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，当遇到占用8字节以上空间的数据项时，**则会按照高位在前的方式分割成若干个8位字节进行存储**。**中间没有分隔符，所以Class文件内容都是被严格限定的**。

Class文件中结构只有两个类型--无符号和表

**无符号**

基本的数据类型，u1,u2,u4,u8表示1个字节，2个字节，4个字节，8个字节的无符号数

**表**

由多个无符号数或者其他表作为数据结构项构成复合数据数据类型，表都是习惯性以_info结尾。整个Class文件本质上就是一张表

|      类型      |        名称         |          数量           |       说明       |
| :------------: | :-----------------: | :---------------------: | :--------------: |
|       u4       |        magic        |            1            | 魔术 0xCAFEBABE  |
|       u2       |    minor_version    |            1            |     次版本号     |
|       u2       |    major_version    |            1            |     主版本号     |
|       u2       | constant_pool_count |            1            | 常量池容量计数值 |
|    cp_info     |    constant_pool    | constant_pool_count - 1 |                  |
|       u2       |    access_flags     |            1            |     访问标志     |
|       u2       |     this_class      |            1            |      类索引      |
|       u2       |     super_class     |            1            |     父类索引     |
|       u2       |  interfaces_count   |            1            |   接口索引集合   |
|       u2       |     interfaces      |    interfaces_count     |                  |
|       u2       |    fields_count     |            1            |    字段表集合    |
|   field_info   |       fields        |      fields_count       |                  |
|       u2       |    methods_count    |            1            |                  |
|  method_info   |       methods       |      methods_count      |    方法表集合    |
|       u2       |  attributes_count   |            1            |                  |
| attribute_info |     attributes      |    attributes_count     |    属性表集合    |



### 字节码指令

Java虚拟机的指令由一个字节长度的，**代表着某种特定操作含义的数据（称为操作码，Opcode）**以及跟随后的**零至多个代表此操作所需参数（称为操作数，Operands）**而构成。类似于机器指令，在属性表集合中的Code属性中。Java的操作码只有1个字节长度。

####操作码助记符

i代表int类型数据操作，l代表long，s代表short，b代表byte，c代表char，d代表double，f代表float，a代表reference。**

####加载和存储指令

- 将一个局部变量加载到操作栈 <操作码助记符>load。
- 将一个数值从操作栈存储到局部变量表 <操作码助记符>store
- 将一个常量加载到操作栈，bipush，sipush，ldc，ldc_w, ldc2_w, aconst_null, iconen_m1, iconst__\<i>, lconst\_\<l>, fconst_\_\<f>, dconst\__\<d>, 
- 扩充局部变量表的访问索引指令，wide
- 把一个数组元素加载到操作数栈的指令，<操作码助记符>aload

- 将一个操作数栈的值存储到数组元素中的指令，<操作码助记符>astore



#### 运算指令符

- 加法指令，<操作码助记符>add

- 减法指令，<操作码助记符>sub

- 乘法指令，<操作码助记符>mul

- 除法指令，<操作码助记符>div

- 求余指令，<操作码助记符>rem

- 取反指令，<操作码助记符>neg

- 位移指令，ishl, ishr, iushr, lshl, lshr, lushr

- 按位或指令，ior, lor

- 按位与指令，iand, land

- 按位异或指令，ixor, lxor

- 局部变量自增指令，iinc

- 比较指令，dcmpg, dcmpl, fcmpg, fcmpl, lcmp



非正规浮点数值， 逐级下溢

#### 类型转换指令

i2b, i2c, i2s,

 l2i,

f2i,f2l,

d2i,d2l,d2f

#### 对象创建与访问指令

- 创建类实例的指令 new
- 创建数组的指令 newarray，anewarray，multianewarray
- 访问类字段和实例字段，getfield，putfield，getstatic，putstatic
- 获取数组长度的指令，arraylength
- 检查类实例类型的指令，instanceof，checkcast

#### 操作数栈管理指令

- 将操作数的栈顶一个或者儿歌元素出栈，pop，pop2
- 复制栈顶一个或两个数值并将复制值或双份复制值重新压入栈顶，dup，dup2，dup_x1,dup2_x1,dup_x2,dup2_x2
- 将栈最顶端的两个数值互换 swap

#### 控制转移指令

- 条件分支， ifeq, iflt, ifle, ifne, ifgt, ifge, ifnull, ifnonnull, if_icmpeq, if_icmpne, if_icmplt, if_icmpgt, if_icmple,if_icmpge, if_acmpeq 和if_acmpne
- 复合条件分支， tableswitch，lookupswitch
- 无条件分支，goto，goto_w，jsr，jsr_w，ret

#### 方法调用和返回指令

**方法调用**

- invokevirtual，调用对象的实例方法
- invokeinterface, 调用接口方法，它会在运行时，搜索一个实现了这个接口方法的对象
- invokespecial，调用一些需要特殊处理的实方法，如**实例初始化方法，实例私有方法或父类方法**
- invokestatic，调用类方法
- invokedynamic，在运行时动态解析出调用点限定符所引用的方法

**返回指令**

- 返回null，return
- 返回类型，<操作码助记符>return

#### 异常处理指令

在java程序中都是有athrow指令实现。在java虚拟机中有异常表实现

####同步指令

Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这个两种同步结构都是使用**管程**实现

方法级的同步，是隐式的。通过方法表中的ACC_SYNCHRONIZED访问标志来申明是否为同步方法。如果是，执行线程要求先成功持有管程，然后在执行方法，执行完之后释放管程。

同步一段指令序列通常由synchronize语句块，由monitorenter和monitorexit两条指令来支持synchronize关键字的语义。

## 虚拟机类加载机制

加载（Loading），验证（Verification），准备（Preparation），解析（Resolution），初始化（Initialization），使用（Using）和卸载（Unloading）7个阶段，其中验证，准备，解析3个阶段称为连接（Linking）。

加载，验证，准备，初始化和卸载这5个阶段的顺序是一定的。

###加载的时机

1. 遇到new，getstatic，putstatic，或invokestatic这4个字节码指令时，如果类没有进行过初始化，则需要先触发其初始化

2. 使用反射类调用时，如果类没有进行初始化，则需要先触发其初始化

3.  当初始化一个类的时候，发现其父类还没有初始化，则需要先触发父类
4. 当虚拟机启动时，用户需要指定一个执行类的主类，虚拟机会先初始化这个主类
5. 如果一个java.lang.invoke.MehtodHandle实例最后的解析结果REF_getStatic, REF_putStatic, REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先触发其初始化

### 类加载的过程

#### 加载

1. 通过一个类的全限定名来获取定义此类的二进制字节流

2. 将这个字节流所代表的静态数据结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问接口

#### 验证（非常重要，但不必须）

1. 文件格式的验证

   主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。通过这个验证之后，**字节流才会进入内存的方法区中存储，所以后面的3个验证阶段都是基于方法区的存储结构进行的。**

2. 元数据验证

   对字节码描述的信息进行语义分析，保证不存在不符合Java语言规范的元数据信息。

3. 字节码验证

   通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。**在第二阶段对元数据信息中的数据类型做完校验后，这个阶段对类的方法体进行校验分析。**

4. 符号引用验证

   确保解析动作能够正常的进行。

#### 准备

是正式为**类变量**分配内存并设置**类变量**初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这里的初始值“通常情况下”是数据类型的零值。

```
public static int value = 123
```

这里value的值是0。

如果类字段的字段属性表中存在ConstantValue，则会在准备阶段就进行赋值

```
public static final int value = 123
```

这时value的值是123。

#### 解析

虚拟机将常量池内的符号引用替换为直接引用的过程。

**符号引用（Symbolic Reference）**

符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位当前目标即可。**符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。**各个虚拟机实现的内存布局可以不同，但是它们能接受的符号引用必须都是一直的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件中。

**直接引用（Direct Reference）**

直接引用可以是直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局有关。如果有了直接引用，那引用的目标并定已经在内存中实现了。

####初始化

**类初始化是类加载过程中的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全是由虚拟机主导和控制的。**

初始化阶段时执行类构造器<clinit>()方法的过程。

<clinit>()是有编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。

### 类加载器

对于任意一个类，都需要由加载它的类加载器和这个类本身一同确定其在Java虚拟机中的唯一性

#### 双亲委派模型

从Java虚拟机的角度来讲

- 启动类加载器（Bootstrap ClassLoader）这个类加载器使用C++语言实现，是虚拟机的一部分。
- 所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并都继承抽象类java.lang.ClassLoader。

从Java开发人员角度分为是分为3种

- 启动类加载器，负责加载<JAVA_HOME>\lib目录，或被-Xbootclasspath指定的路径，并被虚拟机识别的类库加载到虚拟机内存中。
- 扩展类加载器（Extension ClassLoader），负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中的所有类库。
- 应用程序类加载器（Application ClassLoader）,又叫系统类加载器，一般情况下这个就是程序中默认的类加载器。

**工作流程**

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己加载。



## 虚拟机字节码执行引擎

### 运行时栈帧结构

栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。栈帧存储了方法的局部变量表，操作数栈，动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈道出栈的过程。

只有位于栈顶的栈帧才是有效，称为当前栈帧（Current Stack Frame）,与这个栈帧相关联的方法叫做当前方法（Current Mehod）。

####局部变量表

局部变量表（Local Varible Table）是一组变量值存储空间，用于存放方法参数和方法内定义的局部变量。在Java程序编译为Class文件时，就在方法的Code属性中确定了最大容量。

局部变量表的容量以容量槽（Varible Slot）为最小单位。

**由于局部变量表建立在线程的堆栈上，是线程私有的数据，无论读写两个连接的Slot是否为原子操作，都不会一起数据安全问题。**

在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程。先是分配参数，之后再根据方法体内部定义的变量顺序和作用域分配其余的Slot

####操作数栈

操作数栈（Operand Stack），当方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取数据。

####动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属的方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。

####方法返回地址

第一种是执行引擎遇到了任意一个方法返回的字节码指令。这种退出方法称为正常完成出口（Normal Method Invocation Completion）

另一种，在方法执行遇到了异常，并且这个异常没有在方法体内得到处理。无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常。只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方式称为异常完成出口（Abrupt Method Invocation Completion）

### 方法调用

方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本，暂时还不涉及方法内部的具体运行过程。

#### 解析

字节码中的方法调用指令就一常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转换为直接引用，这种转化称为**静态解析**。另外一部分将在每一次运行期间转化为直接引用，这部分称为**动态连接**。

在类加载阶段，会将其中的一部分符号引用，转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的目标，并且这个方法调用版本在运行期不可修改。主要包括静态方法和私有方法两大类。

**非虚方法**

只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法，私有方法，实例构造器，父类方法，它们在类加载的时候就会把符号引用解析为该方法的直接引用。这些方法称为非虚方法。

final方法也是一种非虚方法。

### 分派

#### 静态分派

所有依赖静态类型来定位执行版本的分派动作，称为静态分派。静态分派的典型应用是**方法重载**。静态分派发生在**编译阶段**，**因此确定静态分派的动作实际上不是由虚拟机执行。**有时自变量不需要定义，所以字面量没有显示的静态类型，它的静态类型只能通过语言上的规则区理解和推断。

#### 动态分派

动态分派和**重写**有着密切关系。

**实现**

为类在方法区中建立一个虚方法表（Virtual Mehtod Table，在invokeinterface执行时也会用到接口方法表Inteface Method Table）。虚方法表中存放着各个方法的实际入口地址。

**方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完成。**

#### 单分派和多分派

方法的接收者与方法的参数统称为方法的宗量。根据分派基于多少种宗量，可以分派划分为单分派和多分派。

单分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择。

#### 动态类型支持

java.lang.invoke

### 基于栈的字节码解释执行引擎

Java编译器输出的指令流，基本上是一种基于栈架构的指令集架构（Instruction Set Architecture IA），指令流中的指令大部分都是基于零地址指令，他们依赖于操作数栈进行工作的。

基于栈的指令集主要优点就是可移植，寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免的受到硬件约束。主要缺点，执行速度相对会稍慢一点。

## 类加载及执行子系统的案例与实战

### Tomcat

在Tomcat目录结构中，有3组目录（“/common/\*”，“/server/\*”和“/shared/*”）可以存放Java类库，另外还可以加上Web应用程序自身的目录“WEB-INF”

放置在/common目录中：类库可以被Tomcat和所有的Web应用程序共同使用

放置上/server目录中：类库可以被Tomcat使用，对所有的Web应用程序都可不见

放置在/shared目录中：类库可被所有的Web应用程序共同使用，但对Tomcat自己不可见

放置在/WebApp/WEB-INF目录中：类库仅仅被此Web应用程序使用，对Tomcat和其他Web应用程序都不可见

### OSGI

一种动态模块化规范





## Java内存模型与线程

### Java内存模型

**其实屏蔽的是操作系统的多级内存模型**

####主内存和工作内存

Java内存模型规定了所有的变量都存储在**主内存（Main Memory）**中，每个线程还有自己的**工作内存（Working Memory）**，线程的工作内存保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取，赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

#### 内存间交互操作

**Java的内存模型中定义了8个操作来完成，虚拟机实现时必须要保证下面提及的每一种操作都是原子的。**

- lock（锁定）作用于主内存的变量，它把一个变量标志为一条线程独占的状态。
- unlock（解锁）作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放之后才能被其他的线程锁定。
- read（读取）作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
- load（载入）作用于工作内存的变量，它把read操作从主内存中获取得到的变量值放入工作内存的副本中
- use（使用）作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令将会执行这个操作。
- assign（赋值）作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- store（存储）作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
- wirte（写入）作用于主内存的变量，它把store操作从工作内存中得到的变量值放入主内存的变量中。

**基本规则**

- read和load，store和write必须**顺序执行，但是没有保证连续执行**。
- **变量在工作内存中改变了之后必须把该变化同步回主内存中**
- 线程不能无原因（无assgin操作）把数据从线程的工作内存同步回主内存中
- **一个变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化的变量。（必须要先申明？）**
- 一个变量在同一个时刻只允许被一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行好多次，但是必须要执行相同次数unlock
- **对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量**
- 如果没有被lock操作锁定，就不允许对它执行unlock操作
- 对一个变量执行unlock操作之前，必须要此变量同步回主内存中

#### volatile

**volatile**，依然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如果直接在主内存中读写访问一般。

符合以下两个规则，则可以不加锁

- 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值
- 变量不需要与其他的状态变量共同参与不变的约束

**可见性**

当一个线程修改了这个变量的值，新值对于其他线程是可以立即得到的。普通变量在线程间传递均需要通过主内存来完成。

**禁止指令重排**



#### 先行原则

1. 程序次序原则（应该是控制流顺序）
2. 管程锁定原则
3. volatile变量规则
4. 线程启动规则
5. 线程终止规则
6. 线程中断规则
7. 对象终结规则
8. 传递性

### Java与线程

#### 线程的实现

**内核线程实现**

内核线程（Kernel-Level Thread）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射各个处理器上。支持多线程的内核叫做多线程内核

轻量级进程（Light Weight Thread），轻量级进程就是通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核之间1:1的关系称为一对一的线程模型。

会经常在用户态和内核台切换。

**用户线程实现**

用户线程指的是完全建立用户空间的线程库上，系统内核不能感知线程的存在。

**用户线程加轻量级进程实现**

内核线程和用户线程一起使用的方式

#### 线程调度

协同式线程调度（Cooperative Threads-Scheduling）

线程的执行时间由线程本身控制，线程把自己的工作执行完成之后，要主动通知操作系统切换到另一个线程

抢占式线程调度（Preemptive Threads-Scheduling）

每个线程将由操作系统来分配执行时间，线程切换不有线程本身来决定。**Java使用的线程调度方式就是抢占式调度。Java的线程是通过调用操作系统的api来实现的。所以Java提供的线程优先级也是要依赖于系统。**

#### 状态转换

就绪，运行，等待，阻塞，结束

## 线程安全与锁优化

### 线程安全的级别

#### 不可变

####绝对线程安全

不管运行时环境如何，调用者都不需要任何额外的同步措施

#### 相对线程安全

### 实现

#### 互斥

synchronize的是可重入锁

ReentrantLock

1. 等待可中断，当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待。
2. 公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁
3. 锁可以绑定多个条件

#### 非阻塞同步

CAS

#### 无同步方案



### 锁优化

#### 自旋锁和自适应自旋

#### 锁消除

#### 锁粗化

#### 轻量级锁

####偏向锁

